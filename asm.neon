IMPORT Bytecode
IMPORT file
IMPORT sys
IMPORT string

LET Tokens: Dictionary<Number> := {
    "ENTER":        0, 
    "LEAVE":        1,
    "PUSHB":        2,      %| push boolean immediate               |%
    "PUSHN":        3,      %| push number immediate                |%
    "PUSHS":        4,      %| push string immediate                |%
    "PUSHPG":       5,      %| push pointer to global               |%
    "PUSHPPG":      6,      %| push pointer to predefined global    |%
    "PUSHPMG":      7,      %| push pointer to module global        |%
    "PUSHPL":       8,      %| push pointer to local                |%
    "PUSHPOL":      9,      %| push pointer to outer local          |%
    "PUSHI":        10,     %| push 32-bit integer immediate        |%
    "LOADB":        11,     %| load boolean                         |%
    "LOADN":        12,     %| load number                          |%
    "LOADS":        13,     %| load string                          |%
    "LOADA":        14,     %| load array                           |%
    "LOADD":        15,     %| load dictionary                      |%
    "LOADP":        16,     %| load pointer                         |%
    "STOREB":       17,     %| store boolean                        |%
    "STOREN":       18,     %| store number                         |%
    "STORES":       19,     %| store string                         |%
    "STOREA":       20,     %| store array                          |%
    "STORED":       21,     %| store dictionary                     |%
    "STOREP":       22,     %| store pointer                        |%
    "NEGN":         23,     %| negate number                        |%
    "ADDN":         24,     %| add number                           |%
    "SUBN":         25,     %| subtract number                      |%
    "MULN":         26,     %| multiply number                      |%
    "DIVN":         27,     %| divide number                        |%
    "MODN":         28,     %| modulo number                        |%
    "EXPN":         29,     %| exponentiate number                  |%
    "EQB":          30,     %| compare equal boolean                |%
    "NEB":          31,     %| compare unequal boolean              |%
    "EQN":          32,     %| compare equal number                 |%
    "NEN":          33,     %| compare unequal number               |%
    "LTN":          34,     %| compare less number                  |%
    "GTN":          35,     %| compare greater number               |%
    "LEN":          36,     %| compare less equal number            |%
    "GEN":          37,     %| compare greater equal number         |%
    "EQS":          38,     %| compare equal string                 |%
    "NES":          39,     %| compare unequal string               |%
    "LTS":          40,     %| compare less string                  |%
    "GTS":          41,     %| compare greater string               |%
    "LES":          42,     %| compare less equal string            |%
    "GES":          43,     %| compare greater equal string         |%
    "EQA":          44,     %| compare equal array                  |%
    "NEA":          45,     %| compare unequal array                |%
    "EQD":          46,     %| compare equal dictionary             |%
    "NED":          47,     %| compare unequal dictionary           |%
    "EQP":          48,     %| compare equal pointer                |%
    "NEP":          49,     %| compare unequal pointer              |%
    "ANDB":         50,     %| and boolean                          |%
    "ORB":          51,     %| or boolean                           |%
    "NOTB":         52,     %| not boolean                          |%
    "INDEXAR":      53,     %| index arrayfor read                  |%
    "INDEXAW":      54,     %| index arrayfor write                 |%
    "INDEXAV":      55,     %| index array value                    |%
    "INDEXAN":      56,     %| index array value,no except          |%
    "INDEXDR":      57,     %| index dictionary for read            |%
    "INDEXDW":      58,     %| index dictionary for write           |%
    "INDEXDV":      59,     %| index dictionary value               |%
    "INA":          60,     %| in array                             |%
    "IND":          61,     %| in dictionary                        |%
    "CALLP":        62,     %| call predefined                      |%
    "CALLF":        63,     %| call function                        |%
    "CALLMF":       64,     %| call module function                 |%
    "CALLI":        65,     %| call indirect                        |%
    "JUMP":         66,     %| unconditional jump                   |%
    "JF":           67,     %| jump if false                        |%
    "JT":           68,     %| jump if true                         |%
    "JFCHAIN":      69,     %| jump and drop next if false          |%
    "DUP":          70,     %| duplicate                            |%
    "DUPX1":        71,     %| duplicate under second value         |%
    "DROP":         72,     %| drop                                 |%
    "RET":          73,     %| return                               |%
    "CALLE":        74,     %| call external                        |%
    "CONSA":        75,     %| construct array                      |%
    "CONSD":        76,     %| construct dictionary                 |%
    "EXCEPT":       77,     %| throw exception                      |%
    "CLREXC":       78,     %| clear exception                      |%
    "ALLOC":        79,     %| allocate record                      |%
    "PUSHNIL":      80,     %| push nil pointer                     |%
    "JNASSERT":     81,     %| jump if assertions disabled          |%
    "RESETC":       82,     %| reset cell                           |%
}

LET Directives: Dictionary<Number> := {
    ".GlobalSize":   1,     %| Sets the global variable size        |%
    ".const":        2,     %| Sets a value to an Identifier        |%    
}

LET source: String := sys.args[1]

FUNCTION makeOutputFilename(s: String): String
    VAR dir, fn: String := ""
    file.pathSplit(s, OUT dir, OUT fn)
    IF NOT string.hasSuffix(fn, ".neona") THEN
        print("Not a valid neon assembly file.")
        sys.exit(1)
    END IF
    RETURN file.pathJoin(dir, fn[FIRST TO LAST-6] & ".neonx")
END FUNCTION

FUNCTION parseString(s: String): String
    VAR i: Number := 0
    VAR r: String := ""

    WHILE i <= s.length() DO
        VAR c: String := s[i]
        IF c = "\"" THEN
            INC i
            WHILE i < s.length() DO
                c := s[i]
                INC i
                IF c = "\"" THEN
                    RETURN r
                END IF
                IF i >= s.length() THEN
                    print("unterminated string constant")
                    sys.exit(1)
                END IF
                IF c = "\n" THEN
                    print("unterminated string constant")
                    sys.exit(1)
                END IF
                r.append(c)
            END WHILE
        END IF
        INC i
        r.append(c)
    END WHILE
    RETURN r
END FUNCTION

LET outfn: String := makeOutputFilename(source)
LET lines: Array<String> := file.readLines(source)
VAR code: Bytecode.Bytecode := Bytecode.Bytecode()
code.reset()
VAR Constants: Dictionary<String> := {}
VAR Labels: Dictionary<Number> := {}
VAR numLines: Number := lines.size()

FOREACH s IN lines INDEX i DO
    IF s = "" OR s[0] = ";" THEN
        NEXT FOREACH
    END IF
    VAR line: String := ""
    VAR ln: String := s
    IF string.find(s, ";") > 0 THEN
        ln := string.trim(s[FIRST TO string.find(s, ";")-1])
    END IF
    IF ln[0] = ":" THEN
        IF ln[1 TO LAST] IN Labels THEN
            print("Duplicate label definition on line \(i).")
            sys.exit(1)
        END IF
        Labels[ln[1 TO LAST]] := code.getCurrentAddress()
        NEXT FOREACH
    END IF
    VAR ref: Number := 0
    LET words: Array<String> := string.split(ln, " ")
    IF string.hasPrefix(words[0], ".") THEN
        LET directives: Array<String> := string.split(ln, ":")
        IF directives[0] IN Directives THEN
            CASE directives[0]
                WHEN ".GlobalSize" DO
                    code.global_size := code.global_size + num(directives[1])
                WHEN ".const" DO
                    LET values: Array<String> := string.split(directives[1], " ")
                    IF values.size() < 2 THEN
                        print("Missing value:  Expected constant value; line \(i).")
                        sys.exit(1)
                    END IF
                    IF values[0] IN Constants THEN
                        print("Duplicate Identifier on line \(i): \(values[0])")
                        sys.exit(1)
                    END IF
                    Constants[values[0]] := values[1]
            END CASE
        END IF
        NEXT FOREACH
    END IF
    IF words[0] IN Tokens THEN
        code.code.append(Tokens[words[0]])
        line.append(str(Tokens[words[0]]))
        line.append("\t" & words[0])
        LET operand: String := ln[words[0].length() + 1 TO LAST]
        CASE words[0]
            WHEN "PUSHN" DO                                         % push number immediate
                IF operand IN Constants THEN
                    ref := code.addString(Constants[operand])
                ELSE
                    ref := code.addString(operand)
                END IF
                line.append(" \(ref)")
                code.referenceString(ref)
            WHEN "CALLP" DO                                         % call predefined
                ref := code.addString(operand)
                line.append(" \(ref)")
                code.referenceString(ref)
            WHEN "PUSHS" DO                                         % push string immediate
                IF operand[0] # "\"" THEN
                    print("Expected \".")
                    sys.exit(1)
                END IF
                ref := code.addString(parseString(operand))
                line.append(" \(ref)")
                code.referenceString(ref)
            WHEN "PUSHPG" DO                                        % push pointer to global
                IF operand IN Constants THEN
                    ref := num(Constants[operand])
                ELSE
                    ref := num(operand)
                END IF
                line.append(" \(ref)")
                code.referenceVariable(ref)
            WHEN "STOREN" DO                                        % store number
                line.append("") % TODO: print the variable name, or imediate value if there is one.
            WHEN "LOADN" DO                                         % load number
                line.append("") % TODO: print the variable name, or imediate value if there is one.
            WHEN "JUMP" DO
                IF operand IN Labels THEN
                    ref := Labels[operand]
                ELSE
                    print("Undefined label: \(operand) on line \(i).")
                    sys.exit(1)
                END IF
                code.referenceAddress(ref)
                line.append(" \(ref)")
        END CASE
    ELSE
        print("Invalid operand on line \(i): \(words[0])")
        sys.exit(1) % Invalid operand.
    END IF
    print(line)
END FOREACH
print("Compiled \(numLines) lines.")

code.toFile(outfn)
